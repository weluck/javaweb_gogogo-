java的引用并不是引用，而是隐藏的指针！！！要把java的引用当作指针来看！！！

而c++的引用才是真正的引用

java的引用只是能操作原内存，不能操作指向内存的指针，而c++的引用不仅是操作原内存，更是操作指向原内存的指针！

c++里对对象的引用相当于二级指针，而java里的引用只是一级指针

new 类名();创建对象
类名 xxx 创建对象的引用

JAVA的引用反应到c里准确有三点

类 string s = new string();

一、java的引用实际上是个一级指针，
在使用new的对象对其赋值时，new的对象省略了&，平时使用java的引用时省略了*即真实应该是string * s1 = new string(); string * s2 = new string();

二、在对象的引用之间互相赋值时，都是赋的各自存储的地址值，
即s1 = s2;也就说，java无法存在二阶指针，因为创建出来的实际上都是一级指针。而c++里一级指针的引用（当然实际上他是个二级指针），为 string * & s3 = s1;当*s3时可以修改s1所指向的内存，但引用的作用在于，他也可以修改s1所存储的地址，例s3 = new string();此时s1的地址也已经变化，总得来说

c++的引用时高阶指针向低阶指针，而java引用是同阶指针指向同阶指针，总得来说其实都是一阶指针，故其实都是自身存储的地址值在相互间的传递，而不是将自身地址值赋给其他的指针

故java中引用间互相传递可以更改所指向的共同内存，却无法更改各自所存储的地址值，即无法更改各自的引用所指向的方向

且java中只有值传递没有引用传递
以下两个程序可以证明：
public class Test2 {

       public static void main(String[] args) {

        StringBuffer sb = new StringBuffer("Hello ");

        System.out.println("Before change, sb = " + sb);

        changeData(sb);

        System.out.println("After changeData(n), sb = " + sb);

    }

      

       public static void changeData(StringBuffer strBuf) {

        strBuf.append("World!");

    }

}

先看输出结果：

Before change, sb = Hello

After changeData(n), sb = Hello World!

从结果来看，sb的值被改变了，那么是不是可以说：对象作为参数传递时，是把对象的引用传递过去，如果引用在方法内被改变了，那么原对象也跟着改变。从上面例子的输出结果来看，这样解释是合理。

现在我们对上面的例子稍加改动一下：

public class Test3 {

       public static void main(String[] args) {

        StringBuffer sb = new StringBuffer("Hello ");

        System.out.println("Before change, sb = " + sb);

        changeData(sb);

        System.out.println("After changeData(n), sb = " + sb);

    }

      

       public static void changeData(StringBuffer strBuf) {

           strBuf = new StringBuffer("Hi ");

           strBuf.append("World!");

    }

}

按照上面例子的经验：对象作为参数传递时，是把对象的引用传递过去，如果引用在方法内被改变了，那么原对象也跟着改变。你会认为应该输出：

Before change, sb = Hello

After changeData(n), sb = Hi World!

但运行一下这个程序，你会发现结果是这样的：

Before change, sb = Hello

After changeData(n), sb = Hello
