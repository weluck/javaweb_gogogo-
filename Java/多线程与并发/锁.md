## 死锁
* 多个线程各自占有一-些共享资源,并且互相等待其他线程占有的资源才能运行,而
导致两个或者多个线程都在等待对方释放资源,都停止执行的情形.某一个同步块
同时拥有“两个以上对象的锁”时,就可能会发生“死锁”的问题.

## Lock锁
* 从JDK 5.0开始，Java提供了更强大的线程同步机制一通过 显式定义同步锁对
象来实现同步。同步锁使用L ock对象充当
* java.util.concurrent.locks.Lock接口是 控制多个线程对共享资源进行访问的工具。
锁提供了对共享资源的独占访问，每次只能有一-个线程对L ock对象加锁，线程开
始访问共享资源之前应先获得L ock对象
* ReentrantLock 类实现了Lock ，它拥有与synchronized相同的并发性和内存语
义，在实现线程安全的控制中，比较常用的是ReentrantL .ock,可以显式加锁、释
放锁。
```java
class A{
private final ReentrantLock lock = new ReenTrantLock();
public void m(){
  lock.lock();
  try{
    1/保证线程安全的代码;
  }
  finally{
    lock.unlock();
    //如果同步代码有异常,要将unlock()写 入finally语句块
   }
}
```
## synchronized与lock的区别
* Lock是显式锁(手动开启和关闭锁，别忘记关闭锁) synchronized是隐式锁， 出了作用域自动释放
* Lock只有代码块锁，synchronized有代码块锁和方法锁
* 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性(提供更多的子类)
优先使用顺序:
  * Lock >同步代码块(已经进入了方法体，分配了相应资源) >同步方法(在方法体之外)
