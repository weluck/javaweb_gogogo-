  哈希表（Hash table，也叫散列表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。
  
JDK1.7：数组+链表<br>
JDK1.8：hash表=数组+链表+红黑树

  在HashMap中，当添加元素时，会通过哈希值和数组的长度来计算得出一个计算下标，用它来准确的定位该元素应该put的位置。通常，我们为了使元素分布均匀会使用取模运算，用一个值去模上总长度，例如：

`index = hashCode % arr.length`

  计算出index后，就会将该元素添加进去，理想状态下是将每个值都均匀的添加到数组中，但问题是不可能达到这样的理想状态，这时候就会产生哈希冲突

## 解决Hash冲突四个方法

**1、开放定址法（以冲突的下标为基础再次记算hash，直到不冲突）**

这种方法也称再散列法，其基本思想是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。

**2、重Hash法（多个hash函数，一个hash函数计算出来的索引冲突了就换一个函数记算，直到不冲突）**

这种方法是同时构造多个不同的哈希函数，当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。

**3、链地址法**

这种方法的基本思想是将所有哈希地址为 i 的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第 i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。

**4、建立公共溢出区**

将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区。

## 红黑树

  之前的情况，当链表的长度过长时，其固有弊端就显现出来了，即查询效率较低，链表查询的时间复杂度是O(n),数组的查询时间复杂度是O(1)，链表查询效率非常低，所以就引出了第三种数据结构——红黑树，**链表长度>=8时链表转为红黑树**，红黑树是一棵接近于平衡的二叉树，其查询时间复杂度为O(logn)，远远比链表的查询效率高。
